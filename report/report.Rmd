---
title: "Restauration d'image à l'aide d'algorithme stochastiques par chaînes de Markov"
output: html_notebook
bibliography: report.bib  #https://rmarkdown.rstudio.com/authoring_bibliographies_and_citations.html
---
```{r}
#library(magrittr)
#library(imager)
library(stats)
library(survival)
```

>> **Différence entre l'approche bayésienne et non bayésienne**
>
Pour une configuration initiale donnée, on va pouvoir considérer de nouvelles configurations candidates pour la remplacer. Il sagit alors de savoir quelle candidate est la meilleure. Deux manières de faire sont ici présentées: une approche bayésiennes, et non bayésiennes.  
Pour une approche non bayésienne du problème, l'évaluation d'une configuration candidate est booléenne: soit on accepte le candidat, soit on le rejete, autrement dit la probabilité d'une nouvelle configuration vaut 0 ou 1, car on n'a aucune information apriori sur la configuration de l'image.  
Différement, avec une analyse bayésienne d'une candidate, on dispose d'informations à priori sur cette dernière, et on lui attribuera ainsi une probabilité entre 0 et 1 d'être la meilleure.

# méthodes non bayésiennes

## Algorithmes

### Outil pour les algorithmes

#### Fonction de génération d'image

```{r}
imageGenerator=function(forme, N){
  #fonction permettant de générer une matrice-image de forme choisie, et de taille N*N
  
  img <- matrix(-1, nrow= N, ncol= N)
  
  #----rectangle----
  if(forme== "rectangle"){
    img[(N/4):(N*3/4),(N/4):(N*3/4)] <- 1}
  
  #----losange----
  if(forme== "losange"){
    for (i in 1:N){
      for (j in 1:N){
        sigma0[i,j]=-1+2*(abs(i-j)<=N/4)*(abs(i+j-N)<=N/4)  
      }
    }#for
  }#if
  
  #----damier----
  #----triangle----
  #----cercle----
  #----bande----
  
  return(img)
}#func
```
#### fonction de bruitage d'image
```{r}
bruiteur=function(image, br){
  #fonction qui revoit l'image donnée en argument par la même image mais bruité par la méthode "br"
  imgBr <- image
  N <- #RECUP LONGEUR IMAGE
  bruit <- 0
  #----binomiale----
  if(br== "rbinom"){bruit <- matrix(2*rbinom(N^2,1,1-p)-1,nrow=N,ncol=N)}
  #----poisson----
  #----normale----
  
  imgBr <- image*br
  return(imgBr)
}#func  A FINIR
```
#### fcontion de calcul de l'énergie générale d'une image

```{r}
energie=function(S){
  #fonction pour mesurer l'enrgie globale d'une image
  
  eligne=0
  for (i in 1:N) {for (j in 1:(N-1)){eligne=eligne+S[i,j]*S[i,j+1]}}
  ecolonne=0
  for (j in 1:N) {for (i in 1:(N-1)){ecolonne=ecolonne+S[i,j]*S[i+1,j]}}
  return(eligne+ecolonne)
}
```



### Algorithme de métropolis

```{r}
#========================================================================================================

metropolisIsing=function(forme, N, beta, B, n){
  #fonction qui réalise l'algorithme de Metropolis sur une image img0 qui est bruité en img1, et doit à la fin être restaurée en img2
  
  #----création de l'image parfaite img0----
  img0 = imageGenerator(forme, N)
  image(img0)
  #----création d'une image auxiliaire img1, avec bord plus long et bruitage----
  img1 = matrix(0, nrow=N+2, ncol=N+2)
  bruit = matrix(2*rbinom(N^2,1,1-p)-1,nrow=N,ncol=N)
  img1[2:(N+1),2:(N+1)] = img0*bruit
  image(img1)
  img2 = img1 #image tampon
  for(k in 1:n){
    #----choix d'un site---
    i <- 1+ceiling(N*runif(1)) # indice entre 2 et N+1
    j <- 1+ceiling(N*runif(1))
    #iaux <- 2 + k%%N #de 2 à N+1
    #jaux <- 2 + k%/%(N-1)%%N #de 2 à N+1
    #----tirage nouvelle valeure candidate----
    img2[i,j] = -img1[i,j]
    #----voisinage----
    v = img1[i+1,j] + img1[i-1,j] + img1[i,j+1] + img1[i,j-1]
    #----potentiels----
    U1 = -B*img1[i,j]-beta*img1[i,j]*v
    U2 = -B*img2[i,j]-beta*img2[i,j]*v
    #----test----
    dU = U2-U1
    if(dU<0){img1[i,j]= -img1[i,j]}
    else{
      p <- exp(-dU)
      if(runif(1)<=p){img1[i,j]= -img1[i,j]}
      else{img2[i,j] <- img1[i,j]} #sinon on ne change pas
    }#else
  }#for
  #----affichage----
  #par(mfrow=c(1,3))
  image(img1)
}

#========================================================================================================
```

```{r}
metropolisIsing("rectangle", 64, 1, 0, 10^4)

```

### Algorithme de Gibbs

```{r}
#========================================================================================================

GibbsIsing=function(forme, N, beta, B, n){
  #fonction qui réalise l'algorithme de Metropolis sur une image img0 qui est bruité en img1, et doit à la fin être restaurée en img2
  
  #----création de l'image parfaite img0----
  img0 = imageGenerator(forme, N)
  image(img0)
  #----création d'une image auxiliaire img1, avec bord plus long et bruitage----
  img1 = matrix(0, nrow=N+2, ncol=N+2)
  bruit = matrix(2*rbinom(N^2,1,1-p)-1,nrow=N,ncol=N)
  img1[2:(N+1),2:(N+1)] = img0*bruit
  image(img1)
  img2 = img1 #image tampon
  
  for(k in 1:n){
    #----choix d'un site---
    i <- 1+ceiling(N*runif(1)) # indice entre 2 et N+1
    j <- 1+ceiling(N*runif(1))
    #iaux <- 2 + k%%N #de 2 à N+1
    #jaux <- 2 + k%/%(N-1)%%N #de 2 à N+1
    
    
    #----changement de valeur au site visé sur img2 (1ou-1) pour représenter E en entier avec img1 et img2 (cas d'une image en noir et blanc)----
    img2[i,j] = -img1[i,j]
    #----voisinage----
    v = img1[i+1,j] + img1[i-1,j] + img1[i,j+1] + img1[i,j-1]
    #----potentiels----
    U1 = -B*img1[i,j]-beta*img1[i,j]*v
    U2 = -B*img2[i,j]-beta*img2[i,j]*v
    #----calcule de la proba conditionnelle locale----
    P <- exp(-U1)/(exp(-U1)+exp(-U2))
    #----test----
    if(runif(1)<=p){img1[i,j]= -img1[i,j]}
    else{img2[i,j] <- img1[i,j]} #opération inverse, on ne retient pas le changement.S
  }#for
  #----affichage----
  #par(mfrow=c(1,3))
  image(img1)
}

#========================================================================================================
```
```{r}
GibbsIsing("rectangle", 64, 1, 5, 20)
```


[//]: <> (===============================================================================================================) 
# méthodes bayésiennes
[//]: <> (===============================================================================================================)
## algorithmes
[//]: <> (===============================================================================================================)
### recuit simulé
[//]: <> (===============================================================================================================)

```{r}
#========================================================================================================

#recuitSimule(10^5,2/3,64,0.2,0.3)
recuitSimule = function(n, beta, N, p, alpha, stop){
  
  #----création de sigma0 le rectangle initial----
  sigma0 <- matrix(-1,nrow=N,ncol=N)  
  sigma0[(N/4):(N*3/4),(N/4):(N*3/4)] <- 1
  
  #----création de sigma le rectangle bruité----
  bruit <- matrix(2*rbinom(N^2,1,1-p)-1,nrow=N,ncol=N) 
  sigma <- sigma0*bruit  
  
  #----création image auxiliaire, avec contour suplémentaire pour calculer U plus facilement----
  Saux <- matrix(0, nrow=N+2, ncol=N+2) 
  Saux[2:(N+1),2:(N+1)] <- sigma
  sigmaaux <- Saux #sugmaaux = matrice auxiliaire pour le calcule de U, garde la valeur initiale de Saux (qui lui change)

  
  #--------le recuit simulé--------
  if(stop==0){ #cas où on s'arrête simplement après n itérations
    for (k in (1:n)) {
      #T <- 1/sqrt(sqrt((1+log(k))))
      T <- 1/k #T tend lentement vers 0
      iaux <- 1+ceiling(N*runif(1)) # indice entre 2 et N+1
      jaux <- 1+ceiling(N*runif(1))
      #iaux <- 2 + k%%N #de 2 à N+1
      #jaux <- 2 + k%/%(N-1)%%N #de 2 à N+1
      
      
      #----voisinage----
      s <- Saux[iaux-1,jaux]+Saux[iaux+1,jaux]+Saux[iaux,jaux-1]+Saux[iaux,jaux+1]
      #print("s")
      #print(s)
      #----proba pour un recuit simulé, avec rapport de métropolis----
      r <- exp(-2*Saux[iaux,jaux]*(2*alpha*T*sigmaaux[iaux,jaux]+beta*s)/T)
      
      #----changement ou non de spin selon la proba r---
      if(runif(1)<r){Saux[iaux,jaux] <- -Saux[iaux,jaux]}
    }#for
  }#if
    
  if(stop==1){#cas ou on s'arrête après n itérations sans changement de spin
    X<-0#nombre d'itérations consécutives sans changement de spin
    it<-0
    while(X<=n) {
      it<-it+1
      #T <- 1/sqrt(sqrt((1+log(k))))
      T <- 1/k #T tend lentement vers 0
      iaux <- 1+ceiling(N*runif(1)) # indice entre 2 et N+1
      jaux <- 1+ceiling(N*runif(1))
      #iaux <- 2 + k%%N #de 2 à N+1
      #jaux <- 2 + k%/%(N-1)%%N #de 2 à N+1
      
      
      #----voisinage----
      s <- Saux[iaux-1,jaux]+Saux[iaux+1,jaux]+Saux[iaux,jaux-1]+Saux[iaux,jaux+1]
      
      #----proba pour un recuit simulé----
      r <- exp(-2*Saux[iaux,jaux]*(2*alpha*T*sigmaaux[iaux,jaux]+beta*s)/T)
      
      #----changement ou non de spin selon la proba r---
      if(runif(1)<r){
        Saux[iaux,jaux] <- -Saux[iaux,jaux]
        X <- 0#on vient de changer un spin, donc la condition d'arrêt retombe à 0
      }#if
      else{X <-X+1 } 
    }#while
    print(it)
  }#if
  
  S <- Saux[2:(N+1),2:(N+1)] #image finale (on retire le contour auxiliaire)
    
    
  #----pourcentage de correspondance----
  nok <- 0 #nombre de pixels divergents
  correspondance <- 0 #pourcentage sur nb pixels total
  for (i in (1:N)){
    for (j in (1:N)){
      if(S[i,j] != sigma0[i,j]){nok <- nok+1}
    }#for
  }#for
  correspondance <- ((N^2)-nok)/(N^2)*100
  #print(nok)
  #print(correspondance)
  
  
  #----affichage----
  par(mfrow=c(1,3))
  image(1:N,1:N,sigma0)
  image(1:N,1:N,sigma)
  image(1:N,1:N,S)
  return(correspondance)
}#function

#========================================================================================================
```
```{r}
recuitSimule(10^4, 5, 64, 0.2, 3, 1)
```


### Estimateur MAP
$L(x,x')=1\text{  pour  }x\neq x',\text{et 0 sinon}$
$E[L(X,\phi(y))|y]=1-P(X=\phi(y)|y)$

### estimateur MPM

### estimateur TPM



[//]: <> (===============================================================================================================) 
# Adaptabilité du calcul de potentiel
[//]: <> (===============================================================================================================) 
## groupe de voisin
[//]: <> (===============================================================================================================) 

On va essayer d'augmenter la précision des algorithmes précédents en jouant sur la définition du voisinage. On définis le voisinage possible comme une étoile à huit branches. La longueur de chaque branche (et donc son poid dans le calcul de U) va dépendre de la continuité des pixels constituant cette branche. Ainsi d'un pixel à l'autre on n'aura pas forcément un voisinage de même ampleur.\ 
La longeur d'un branche est égale au nombre de pixels côte à côte suivant l'orientation de la branche, de même valeur (pour une image en noir et blanc), partant de s.\ 
Le poid d'une branche de voisinage est alors proportionel à sa longeur. On aurait:
$U_s=Bx_s+\beta x_s\sum_{i=1}^{8}{a_il_i}$
avec $(l_i)$ les 8 lead et $(a_i)$ leur longueur.

On pourrait envisager de limiter la longeur des branches à 5 ou 10.

### constitution du voisinage

1. ajout des 8 plus proches voisins (habituel, si ce n'est que l'on ajoute les diagonales en plus). On les note lead.
2. pour chacun des lead, on regarde la valeur du pixel qui le jouxe dans l'orientation de la flêche auquel il appartient, opposément à s biensûr. Si ce pixel est de même valeur que le lead, on l'intègre à la branche. Sinon, la branche et terminée (cas d'un image en noir et blanc).

```{r}
#========================================================================================================

Vbranch2=function(img, is, js, ib, jb){
  #fonction qui forme une branche de voisinage de s
  
  #----VARIABLES----
  dii <- ib-is #coord ligne 
  djj <- jb-js#coord colonnes
  branch = 0
  lead <- img[ib,jb]
  cdd = 0 #candidat
  k <- 1
  
  #----FONCTION----
  
  #----branche horizontale----
  if(dii==0){
    
    #--orientée gauche--
    if(djj<0){
      cdd <- img[ib,jb-k]
      if(cdd==lead){
        while(cdd==lead){
          branch <- branch + cdd
          k <- k+1
          cdd <- img[ib,jb-k]
        }#while
      }#if
      else{branch <- branch + cdd}
      return(branch)
    }#if
    
    #--orientée droite--
    else{
      cdd <- img[ib,jb+k]
      if(cdd==lead){
        while (cdd==lead) {
          branch <- branch + cdd
          k <- k+1
          cdd <- img[ib,jb+k]
        }#while
      }#if
      else{branch <- branch + cdd}
      return(branch)
    }#else
  }#if
  
  #----branche verticale----
  if(djj==0){
    
    #--orientée bas--
    if(dii<0){
      cdd <- img[ib+k,jb]
      if(cdd==lead){
        while(cdd==lead){
          branch <- branch + cdd
          k <- k+1
          cdd <- img[ib+k,jb]
        }#while
      }#if
      else{branch <- branch + cdd}
      return(branch)
    }#if
    
    #--orientée haut--
    else{
      cdd <- img[ib-k,jb]
      if(cdd==lead){
        while(cdd==lead){
          cdd <- img[ib-k,jb]
          k <- k+1
          cdd <- img[ib-k, jb]
        }#while
      }#if
      else{branch <- branch + cdd}
      return(branch)
    }#else
  }#if
}#func

#========================================================================================================
```

```{r}
#========================================================================================================

Vbranch=function(img, is, js, ib, jb){
  #fonction qui forme une branche de voisinage de s
  
  #----VARIABLES----
  dii <- ib-is #coord ligne 
  djj <- jb-js#coord colonnes
  branch = 0
  lead <- img[ib,jb]
  cdd = 0 #candidat
  k <- 1
  
  #----FONCTION----
  #----branche horizontale----
  
  if(dii==0){
    #--orientée gauche--
    if(djj<0){
      cdd <- img[ib,jb-k]
      while(cdd==lead){
        branch <- branch + cdd
        k <- k+1
        cdd <- img[ib,jb-k]
      }#while
      return(branch)
    }#else
    #--orientée droite--
    else{
      cdd <- img[ib,jb+k]
      while (cdd==lead) {
        branch <- branch + cdd
        k <- k+1
        cdd <- img[ib,jb+k]
      }#while
      return(branch)
    }#else
  }#if
  
  #----branche verticale----
  if(djj==0){
    #--orientée bas--
    if(dii<0){
      cdd <- img[ib+k,jb]
      while(cdd==lead){
        branch <- branch + cdd
        k <- k+1
        cdd <- img[ib+k,jb]
      }#while
      return(branch)
    }#if
    #--orientée haut--
    else{
      cdd <- img[ib-k,jb]
      while(cdd==lead){
        cdd <- img[ib-k,jb]
        k <- k+1
        cdd <- img[ib-k, jb]
      }#while
      return(branch)
    }#else
  }#if
}#func

#========================================================================================================
```

```{r}
Vstar=function(img, i,j){
  s <- 0
  s <- s + Vbranch2(img, i, j, i-1, j)
  s <- s + Vbranch2(img, i, j, i+1, j)
  s <- s + Vbranch2(img, i, j, i, j-1)
  s <- s + Vbranch2(img, i, j, i, j+1)
  return(s)
}#func

#========================================================================================================
```

```{r}
img <- imageGenerator("rectangle", 50)
Vstar(img, 20,23)
```



[//]: <> (===============================================================================================================) 
# Probabilité du pourcentage de bon pixels bien représentés en sachant le nombre d'itérations
[//]: <> (===============================================================================================================)
## Fonction de répartition empirique du pourcentage de pixels correctement restitué
[//]: <> (===============================================================================================================)

```{r}
#========================================================================================================

recuitSimule = function(n, beta, N, p, alpha, stop){
  
  #----cr?ation de sigma0 le rectangle initial----
  sigma0 <- matrix(-1,nrow=N,ncol=N)  
  sigma0[(N/4):(N*3/4),(N/4):(N*3/4)] <- 1
  
  #----cr?ation de sigma le rectangle bruit?----
  bruit <- matrix(2*rbinom(N^2,1,1-p)-1,nrow=N,ncol=N) 
  sigma <- sigma0*bruit  
  
  #----cr?ation image auxiliaire, avec contour supl?mentaire pour calculer U plus facilement----
  Saux <- matrix(0, nrow=N+2, ncol=N+2) 
  Saux[2:(N+1),2:(N+1)] <- sigma
  sigmaaux <- Saux #sugmaaux = matrice auxiliaire pour le calcule de U, garde la valeur initiale de Saux (qui lui change)
  #rmc=rep(1/2,n)

  
  #--------le recuit simul?--------
  if(stop==0){ #cas o? on s'arr?te simplement apr?s n it?rations
    for (k in (1:n)) {
      #T <- 1/sqrt(sqrt((1+log(k))))
      T <- 1/k #T tend lentement vers 0
      iaux <- 1+ceiling(N*runif(1)) # indice entre 2 et N+1
      jaux <- 1+ceiling(N*runif(1))
      #iaux <- 2 + k%%N #de 2 ? N+1
      #jaux <- 2 + k%/%(N-1)%%N #de 2 ? N+1
      
      
      #----voisinage----
      s <- Vstar(Saux, iaux, jaux)
      #s <- Saux[iaux-1,jaux]+Saux[iaux+1,jaux]+Saux[iaux,jaux-1]+Saux[iaux,jaux+1]
      
      #----proba pour un recuit simul?----
      r <- exp(-2*Saux[iaux,jaux]*(2*alpha*T*sigmaaux[iaux,jaux]+beta*s)/T)
      
      #----changement ou non de spin selon la proba r---
      #rmc[k]=r
      if(runif(1)<r){Saux[iaux,jaux] <- -Saux[iaux,jaux]}
    }#for
  }#if
    
  if(stop==1){#cas ou on s'arr?te apr?s n it?rations sans changement de spin
    X<-0#nombre d'it?rations cons?cutives sans changement de spin
    it<-0
    while(X<=n) {
      it<-it+1
      #T <- 1/sqrt(sqrt((1+log(k))))
      T <- 1/it #T tend lentement vers 0
      iaux <- 1+ceiling(N*runif(1)) # indice entre 2 et N+1
      jaux <- 1+ceiling(N*runif(1))
      #iaux <- 2 + k%%N #de 2 ? N+1
      #jaux <- 2 + k%/%(N-1)%%N #de 2 ? N+1
      
      
      #----voisinage----
      #s <- Vstar(Saux, iaux, jaux)
      s <- Saux[iaux-1,jaux]+Saux[iaux+1,jaux]+Saux[iaux,jaux-1]+Saux[iaux,jaux+1]
      
      #----proba pour un recuit simul?----
      r <- exp(-2*Saux[iaux,jaux]*(2*alpha*T*sigmaaux[iaux,jaux]+beta*s)/T)
      
      #----changement ou non de spin selon la proba r---
      #rmc[k]=r
      if(runif(1)<r){
        Saux[iaux,jaux] <- -Saux[iaux,jaux]
        X <- 0#on vient de changer un spin, donc la condition d'arr?t retombe ? 0
      }#if
      else{X <-X+1 } 
    }#while
    print(c("ItÃ©rations",it))
  }#if
  
  S <- Saux[2:(N+1),2:(N+1)] #image finale (on retire le contour auxiliaire)
    
    
  #----pourcentage de correspondance----
  nok <- 0 #nombre de pixels divergents
  correspondance <- 0 #pourcentage sur nb pixels total
  for (i in (1:N)){
    for (j in (1:N)){
      if(S[i,j] != sigma0[i,j]){nok <- nok+1}
    }#for
  }#for
  correspondance <- ((N^2)-nok)/(N^2)*100
  #print(nok)
  print(correspondance)
  
  
  #----affichage----
  #layout(matrix(c(1,4,2,5,3,0), nc=3))
  #image(1:N,1:N,sigma0)
  #image(1:N,1:N,sigma)
  #image(1:N,1:N,S)
  return(correspondance)
}#function

#========================================================================================================
```

```{r}
#========================================================================================================

MCdeMC=function(pct, K, n, beta, N, p, alpha, stop){
  #algo de montecarlo sur celui de recuit simul?, pour estimer la proba de correspodnance
  #? pct% d'une image reconstitu?e, en en fonction du nombre d'it?rations dans le recuitsimul?
  P <- 0
  E <- 0
  corresp = rep(0,K)#génère une suite de K zero
  for (k in (1:K)) { #on fait K recuitSimul?
    corresp[k] = recuitSimule(n, beta, N, p, alpha, stop)
    if(corresp[k]>=pct){E <- E+1} #si le pourcentage de correspondance convient ? la condition pct
  }
  
  P <- E/K  #les recuitSimule sont a priori ind?pendants les uns des autres, et r?alis?s identiquement
  print(P)
  
  survie=function(x){1-ecdf(corresp)(x)}
  plot(ecdf(corresp))
  x <- seq(min(corresp)-4,100,0.1)
  #plot.Surv(corresp)
  plot(x,survie(x),type="S")
}

#========================================================================================================
```
```{r}
MCdeMC(98,2,400,2/3,64,0.2,0.3,0)
```

 
[//]: <> (===============================================================================================================) 
# Les paramètres et leur estimation
[//]: <> (===============================================================================================================)
## Modèle d'Ising
[//]: <> (===============================================================================================================)

On rappelle, pour le modèle d'Ising, $E={-1,1}$, et $U(x_s) = \beta -x_s\sum_{t\in V_s}{x_t} -  Bx_s$.
Le choix du signe de beta est déterminant pour la valeur de $U_s(x_s)$. En effet, choisir un beta négatif va imposer que toutes les 2-cliques dont les pixels sont de signes différents auront pour potentiel $-1\times 1\times\beta$, donc un nombre positif, tandis que les 2-cliques de signes identiques auront un potentiel négatif. Or la mesure de Gibbs est telle que plus le potentiel pour un état est élevé, moins ce site est probable d'être dans cette état.




[//]: <> (===============================================================================================================) 
# References